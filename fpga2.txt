library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity MenuSystem is
    Generic (
        DEB_WIDTH : integer := 16  -- width of shift register for debouncing
    );
    Port (
        clk       : in  STD_LOGIC;
        reset     : in  STD_LOGIC;
        btn_left  : in  STD_LOGIC;
        btn_right : in  STD_LOGIC;
        HEX0      : out STD_LOGIC_VECTOR (6 downto 0);
        HEX1      : out STD_LOGIC_VECTOR (6 downto 0)
    );
end MenuSystem;

architecture Behavioral of MenuSystem is
    -- Primary values
    signal value_current : INTEGER range 0 to 9 := 0;
    signal value_chosen  : INTEGER range 0 to 9 := 0;

    -- Debounce shift registers
    signal sr_left  : STD_LOGIC_VECTOR(DEB_WIDTH-1 downto 0) := (others => '0');
    signal sr_right : STD_LOGIC_VECTOR(DEB_WIDTH-1 downto 0) := (others => '0');

    -- Debounced signals
    signal db_left    : STD_LOGIC := '0';
    signal db_right   : STD_LOGIC := '0';

    -- One-shot pulses on rising edge of debounced signals
    signal left_pulse  : STD_LOGIC := '0';
    signal right_pulse : STD_LOGIC := '0';
    signal db_left_r   : STD_LOGIC := '0';
    signal db_right_r  : STD_LOGIC := '0';

    -- Segment encoding
    function to_seven_seg(val : INTEGER) return STD_LOGIC_VECTOR is
        variable seg : STD_LOGIC_VECTOR(6 downto 0);
    begin
        case val is
            when 0 => seg := "1000000";
            when 1 => seg := "1111001";
            when 2 => seg := "0100100";
            when 3 => seg := "0110000";
            when 4 => seg := "0011001";
            when 5 => seg := "0010010";
            when 6 => seg := "0000010";
            when 7 => seg := "1111000";
            when 8 => seg := "0000000";
            when 9 => seg := "0010000";
            when others => seg := "1111111";
        end case;
        return seg;
    end;

begin

    -- Debounce process: shift register method
    process(clk)
    begin
        if rising_edge(clk) then
            -- shift in raw inputs
            sr_left  <= sr_left(DEB_WIDTH-2 downto 0) & btn_left;
            sr_right <= sr_right(DEB_WIDTH-2 downto 0) & btn_right;

            -- update debounced output when all bits agree
            if sr_left = (others => '1') then
                db_left <= '1';
            elsif sr_left = (others => '0') then
                db_left <= '0';
            end if;

            if sr_right = (others => '1') then
                db_right <= '1';
            elsif sr_right = (others => '0') then
                db_right <= '0';
            end if;

            -- one-shot generation
            db_left_r  <= db_left;
            db_right_r <= db_right;
            left_pulse  <= db_left and not db_left_r;
            right_pulse <= db_right and not db_right_r;
        end if;
    end process;

    -- Main menu logic
    process(clk, reset)
    begin
        if reset = '1' then
            value_current <= 0;
            value_chosen  <= 0;
        elsif rising_edge(clk) then
            if left_pulse = '1' then
                if value_current = 9 then
                    value_current <= 0;
                else
                    value_current <= value_current + 1;
                end if;
            end if;

            if right_pulse = '1' then
                value_chosen <= value_current;
            end if;
        end if;
    end process;

    -- Drive 7-segment displays
    HEX0 <= to_seven_seg(value_current);
    HEX1 <= to_seven_seg(value_chosen);

end Behavioral;
